<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Photo Editor</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
    <link rel="stylesheet" href="https://unpkg.com/cropperjs@1.5.11/dist/cropper.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mui/system/css/stack.css" />
    <style>
body {
    font-family: 'Roboto', sans-serif;
    margin: 7px;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background-color: #f4f4f4;
}

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px;
            background-color: #ffffff;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        canvas {
            margin-top: 16px;
            max-width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
.fixed-fullwidth-container {
    position: static;
    width: auto;
    background-color: #f4f4f4;
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    margin: 15px;
    padding: 16px;
}
    </style>
</head>

<body>
    <div class="container">
        <input type="file" id="imageInput" accept="image/*">
        <canvas id="canvas"></canvas>

        <div style="margin-top: 16px;">
            <button onclick="applyFilter('grayscale')">Grayscale</button>
            <button onclick="applyFilter('sepia')">Sepia</button>
            <button onclick="applyFilter('invert')">Invert Colors</button>
            <button onclick="applyFilter('brightness')">Adjust Brightness</button>
            <button onclick="applyFilter('blur')">Blur</button>
        </div>

        <div style="margin-top: 16px;">
            <button id="penToggleButton" onclick="activatePen()">Toggle Pen</button>
            <label for="colorPicker">Color:</label>
            <input type="color" id="colorPicker" value="#000000" onchange="updatePenColor(this.value)">
            <label for="sizeSlider">Size:</label>
            <input type="range" id="sizeSlider" min="1" max="50" value="10" onchange="updatePenSize(this.value)">
        </div>



        <div style="margin-top: 16px;">
            <label for="text">Text:</label>
            <input type="text" id="text" placeholder="Enter text">
            <label for="textColor">Text Color:</label>
            <input type="color" id="textColor" value="#000000" onchange="updateTextColor(this.value)">
            <label for="fontSize">Font Size:</label>
            <input type="number" id="fontSize" min="1" max="100" value="16" onchange="updateFontSize(this.value)">
            <button onclick="addTextAtMousePosition()">Add Text at Mouse Position</button>
        </div>

        <div style="margin-top: 16px;">
            <button onclick="undo()">Undo</button>
            <button onclick="resetImage()">Reset</button>
            <button onclick="downloadImage()">Download Image</button>
        </div>

<div class="fixed-fullwidth-container">
    <img id="cropperImage" style="max-width: 100%;" />
    <button onclick="cancelCrop()">Cancel Crop</button>
    <button onclick="cropImage()">Crop Image</button>
</div>
    </div>

    <script src="https://unpkg.com/cropperjs@1.5.11/dist/cropper.min.js"></script>


    <script>
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let imageInput = document.getElementById('imageInput');
        let img = new Image();
        let originalImageData;
        let dynamicBrightness = 0;
        let dynamicBlur = 0;
        let dynamicBrightnessIncrement = 20;
        let dynamicBlurIncrement = 2;
        let penActive = false;
        let eraseActive = false;
        let brushActive = false;
        let textActive = false;
        let penColor = '#000000';
        let penSize = 10;
        let drawingActions = []; // Array to store drawing actions


        let text = '';
        let textColor = '#000000';
        let fontSize = 16;







        // Initialize cropper
        let cropper;









        imageInput.addEventListener('change', handleImage);






        function handleImage(e) {
            let reader = new FileReader();

            reader.onload = function (event) {
                img.onload = function () {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    saveSnapshot();

                    // Set up cropper
                    document.getElementById('cropperImage').src = event.target.result;
                    if (cropper) {
                        cropper.destroy();
                    }
                    cropper = new Cropper(document.getElementById('cropperImage'), {
                        viewMode: 1,
                        autoCropArea: 1, // Adjust the initial crop area size
                        crop(event) {
                            // Crop event handling
                        },
                        movable: false,
                        rotatable: false,
                        scalable: false,
                        zoomable: true,
                        autoCrop: false,
                        autoCropArea: 1,
                        resizable: false, // Make the cropping area resizable from all points
                    });
                }
                img.src = event.target.result;
            }

            reader.readAsDataURL(e.target.files[0]);
        }







        function cropImage() {
            // Get the cropped data
            let croppedImageData = cropper.getCroppedCanvas().toDataURL();
            
            // Clear the canvas and draw the cropped image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            img.src = croppedImageData;
        }



function cancelCrop() {
    // Clear the canvas and redraw the original image
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);
    // Also reset the cropper
    if (cropper) {
        cropper.destroy();
        cropper = new Cropper(document.getElementById('cropperImage'), {
            viewMode: 1,
            autoCropArea: 1,
            crop(event) {
                // Crop event handling
            },
            movable: false,
            rotatable: false,
            scalable: false,
            zoomable: false,
            autoCrop: false,
            autoCropArea: 1,
            resizable: false,
        });
    }
}





        function applyFilter(filterType) {
            // Apply the selected filter with gradual increase
            switch (filterType) {
                case 'grayscale':
                    applyGrayscale();
                    break;
                case 'sepia':
                    applySepia();
                    break;
                case 'invert':
                    applyInvert();
                    break;
                case 'brightness':
                    dynamicBrightness += dynamicBrightnessIncrement;
                    applyBrightness(dynamicBrightness);
                    break;
                case 'blur':
                    dynamicBlur += dynamicBlurIncrement;
                    applyBlur(dynamicBlur);
                    break;
                // Add more cases for additional filters
                default:
                    break;
            }
        }

        function applyGrayscale() {
            // Grayscale filter logic
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = avg;
                data[i + 1] = avg;
                data[i + 2] = avg;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function applySepia() {
            // Sepia filter logic
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let red = data[i];
                let green = data[i + 1];
                let blue = data[i + 2];

                data[i] = Math.min(255, 0.393 * red + 0.769 * green + 0.189 * blue);
                data[i + 1] = Math.min(255, 0.349 * red + 0.686 * green + 0.168 * blue);
                data[i + 2] = Math.min(255, 0.272 * red + 0.534 * green + 0.131 * blue);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function applyInvert() {
            // Invert colors filter logic
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];       // Invert red
                data[i + 1] = 255 - data[i + 1]; // Invert green
                data[i + 2] = 255 - data[i + 2]; // Invert blue
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function applyBrightness(adjustment) {
            // Brightness filter logic
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] += adjustment;       // Adjust red
                data[i + 1] += adjustment;   // Adjust green
                data[i + 2] += adjustment;   // Adjust blue
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function applyBlur(blurRadius) {
            // Blur filter logic
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    let redTotal = 0;
                    let greenTotal = 0;
                    let blueTotal = 0;
                    let pixelCount = 0;

                    for (let dy = -blurRadius; dy <= blurRadius; dy++) {
                        for (let dx = -blurRadius; dx <= blurRadius; dx++) {
                            let nx = x + dx;
                            let ny = y + dy;

                            if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height) {
                                let index = (ny * canvas.width + nx) * 4;
                                redTotal += data[index];
                                greenTotal += data[index + 1];
                                blueTotal += data[index + 2];
                                pixelCount++;
                            }
                        }
                    }

                    let currentIndex = (y * canvas.width + x) * 4;
                    data[currentIndex] = redTotal / pixelCount;
                    data[currentIndex + 1] = greenTotal / pixelCount;
                    data[currentIndex + 2] = blueTotal / pixelCount;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function flipImage(direction) {
            // Flip image logic
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;

            if (direction === 'horizontal') {
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width / 2; x++) {
                        let index1 = (y * canvas.width + x) * 4;
                        let index2 = (y * canvas.width + canvas.width - x - 1) * 4;

                        // Swap pixel colors for horizontal flip
                        for (let i = 0; i < 4; i++) {
                            let temp = data[index1 + i];
                            data[index1 + i] = data[index2 + i];
                            data[index2 + i] = temp;
                        }
                    }
                }
            } else if (direction === 'vertical') {
                for (let y = 0; y < canvas.height / 2; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        let index1 = (y * canvas.width + x) * 4;
                        let index2 = ((canvas.height - y - 1) * canvas.width + x) * 4;

                        // Swap pixel colors for vertical flip
                        for (let i = 0; i < 4; i++) {
                            let temp = data[index1 + i];
                            data[index1 + i] = data[index2 + i];
                            data[index2 + i] = temp;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        
 function resetImage() {
            ctx.putImageData(originalImageData, 0, 0);
            dynamicBrightness = 0;
            dynamicBlur = 0;
        }



       <!-- ... Existing code ... -->

        function downloadImage() {
            let downloadLink = document.createElement('a');
            downloadLink.href = canvas.toDataURL("image/png");
            downloadLink.download = 'edited_image.png';
            downloadLink.click();
        }

        let drawing = false;
        let lastX, lastY;

        canvas.addEventListener('mousedown', startPosition);
        canvas.addEventListener('mouseup', endPosition);
        canvas.addEventListener('mousemove', draw);

        canvas.addEventListener('touchstart', startPosition);
        canvas.addEventListener('touchend', endPosition);
        canvas.addEventListener('touchmove', draw);

        function startPosition(e) {
            if (penActive || eraseActive || brushActive) {
                drawing = true;
                draw(e);
            }
        }

        function endPosition() {
            drawing = false;
            ctx.beginPath();
        }

        function draw(e) {
    if (!drawing) return;

    ctx.lineWidth = penSize;
    ctx.lineCap = 'round';
    ctx.strokeStyle = penColor;

    if (eraseActive) {
        ctx.globalCompositeOperation = 'destination-out';
    } else {
        ctx.globalCompositeOperation = 'source-over';
    }

    let clientX, clientY;

    if (e.type.startsWith('touch')) {
        clientX = e.touches[0].clientX - canvas.offsetLeft;
        clientY = e.touches[0].clientY - canvas.offsetTop;
    } else {
        clientX = e.clientX - canvas.offsetLeft;
        clientY = e.clientY - canvas.offsetTop;
    }

    if (penActive || eraseActive || brushActive) {
        ctx.beginPath();
        ctx.arc(clientX, clientY, penSize / 2, 0, Math.PI * 2); // Draw a circle at the touch/mouse position
        ctx.fillStyle = penColor;
        ctx.fill();
        ctx.stroke();
    }
}









        function activatePen() {
    let toggleButton = document.getElementById('penToggleButton');
    toggleButton.textContent = penActive ? 'Pen is disabled' : 'Pen is enabled'; 
            if (!penActive) {
                penActive = true;
              canvas.removeEventListener('mousedown', startBrush);
                canvas.removeEventListener('touchstart', startBrush);
 
            } else {

                // Toggle off if it was the same button
                penActive = false;
            }
        }






        function updatePenColor(color) {
            penColor = color;
        }

        function updatePenSize(size) {
            penSize = parseInt(size);
        }

        function addTextAtMousePosition() {
            text = document.getElementById('text').value;
            canvas.addEventListener('click', addTextOnClick);
        }

        function addTextOnClick(event) {
            let x = event.clientX - canvas.offsetLeft;
            let y = event.clientY - canvas.offsetTop;
            drawText(x, y);
            saveSnapshot();
            canvas.removeEventListener('click', addTextOnClick);
        }

        function drawText(x, y) {
            ctx.font = fontSize + 'px Arial';
            ctx.fillStyle = textColor;
            ctx.fillText(text, x, y);
        }

        function updateTextColor(color) {
            textColor = color;
            saveSnapshot();
        }

        function updateFontSize(size) {
            fontSize = parseInt(size);
            saveSnapshot();
        }




 let undoStack = [];
        let lastSnapshot;

        function saveSnapshot() {
            // Save the current canvas state to the undo stack
            undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        }

        function undo() {
            // Undo the last change
            if (undoStack.length > 0) {
                // Pop the last snapshot from the stack
                lastSnapshot = undoStack.pop();
                ctx.putImageData(lastSnapshot, 0, 0);
            }
        }

        canvas.addEventListener('mousedown', function() {
            // Save a snapshot before making a change
            saveSnapshot();
        });

        canvas.addEventListener('touchstart', function() {
            // Save a snapshot before making a change
            saveSnapshot();
        });

        canvas.addEventListener('mouseup', function() {
            // Save a snapshot when the mouse is released after using any tool
            saveSnapshot();
        });

        canvas.addEventListener('touchend', function() {
            // Save a snapshot when the touch ends after using any tool
            saveSnapshot();
        });

        // ... Additional functionalities for Erase can be added here.

    </script>
</body>
</html>
